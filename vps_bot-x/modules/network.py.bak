# -*- coding: utf-8 -*-
# modules/network.py (V6.0.0 å†…ç½‘æ™ºèƒ½ç®¡ç†ç‰ˆ)
import subprocess, re, os, requests, math, ipaddress, netifaces
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from config import load_ports, save_ports, SSH_FILE, load_config

# --- è¾…åŠ©: IP ä¿¡æ¯ç¼“å­˜ ---
IP_CACHE = {}

def get_flag_emoji(country_code):
    """å°†å›½å®¶ä»£ç è½¬æ¢ä¸ºæ——å¸œ Emoji"""
    if not country_code or len(country_code) != 2:
        return "ğŸ‡ºğŸ‡³"
    return "".join([chr(ord(c.upper()) + 127397) for c in country_code])

def get_ip_detail(ip):
    """è·å– IP è¯¦ç»†ä¿¡æ¯ (å¸¦ç¼“å­˜)"""
    query_ip = ip.split('/')[0] if '/' in ip else ip
    
    if query_ip in IP_CACHE:
        return IP_CACHE[query_ip]
    
    try:
        url = f"http://ip-api.com/json/{query_ip}?fields=status,message,countryCode,isp"
        r = requests.get(url, timeout=1.5).json()
        
        if r.get('status') == 'success':
            flag = get_flag_emoji(r.get('countryCode'))
            isp = r.get('isp', 'Unknown')
            if len(isp) > 15:
                isp = isp[:15] + "..."
            info = {'flag': flag, 'isp': isp, 'code': r.get('countryCode')}
        else:
            info = {'flag': "ğŸ´â€â˜ ï¸", 'isp': "Private", 'code': "XX"}
        
        IP_CACHE[query_ip] = info
        return info
    except:
        return {'flag': "ğŸ“¡", 'isp': "Timeout", 'code': "XX"}

def get_ssh_port():
    """å¢å¼ºçš„ SSH ç«¯å£æ£€æµ‹"""
    try:
        out = subprocess.getoutput("sshd -T 2>/dev/null | grep '^port '").strip()
        if out and 'port' in out.lower():
            port = out.split()[-1]
            if port.isdigit():
                return port
    except:
        pass
    
    try:
        if os.path.exists(SSH_FILE):
            out = subprocess.getoutput(f"grep -i '^Port ' {SSH_FILE}").strip()
            if out:
                port = out.split()[-1]
                if port.isdigit():
                    return port
    except:
        pass
    
    return "22"

# ===============================
# ğŸ  å†…ç½‘æ™ºèƒ½ç®¡ç† (æ ¸å¿ƒæ–°å¢)
# ===============================

def detect_local_networks():
    """
    æ™ºèƒ½æ£€æµ‹æœ¬æœºæ‰€æœ‰ç½‘æ®µ
    è¿”å›: [{'network': '192.168.1.0/24', 'interface': 'eth0', 'type': 'current', 'ip': '192.168.1.100'}]
    """
    networks = []
    detected_networks = set()
    
    # æ ‡å‡†ç§ç½‘æ®µ
    STANDARD_PRIVATE = [
        {'network': '10.0.0.0/8', 'type': 'standard'},
        {'network': '172.16.0.0/12', 'type': 'standard'},
        {'network': '192.168.0.0/16', 'type': 'standard'},
        {'network': '127.0.0.0/8', 'type': 'loopback'}
    ]
    
    try:
        # éå†æ‰€æœ‰ç½‘å¡
        for iface in netifaces.interfaces():
            try:
                addrs = netifaces.ifaddresses(iface)
                if netifaces.AF_INET not in addrs:
                    continue
                
                for addr in addrs[netifaces.AF_INET]:
                    ip = addr.get('addr')
                    netmask = addr.get('netmask')
                    
                    if not ip or not netmask:
                        continue
                    
                    # è·³è¿‡éç§ç½‘IP
                    if not ipaddress.ip_address(ip).is_private and ip != '127.0.0.1':
                        continue
                    
                    # è®¡ç®—ç½‘æ®µ
                    network = ipaddress.IPv4Network(f"{ip}/{netmask}", strict=False)
                    network_str = str(network)
                    
                    # é¿å…é‡å¤
                    if network_str in detected_networks:
                        continue
                    
                    detected_networks.add(network_str)
                    
                    # åˆ¤æ–­ç±»å‹
                    if 'docker' in iface.lower():
                        net_type = 'docker'
                    elif 'tun' in iface.lower() or 'tap' in iface.lower() or 'vpn' in iface.lower():
                        net_type = 'vpn'
                    elif 'tailscale' in iface.lower() or 'wg' in iface.lower():
                        net_type = 'vpn'
                    elif ip.startswith('127.'):
                        net_type = 'loopback'
                    else:
                        net_type = 'current'
                    
                    networks.append({
                        'network': network_str,
                        'interface': iface,
                        'type': net_type,
                        'ip': ip
                    })
            except:
                continue
        
        # æ·»åŠ æ ‡å‡†ç§ç½‘æ®µ (å¦‚æœæœªæ£€æµ‹åˆ°)
        for std in STANDARD_PRIVATE:
            if std['network'] not in detected_networks:
                networks.append({
                    'network': std['network'],
                    'interface': 'N/A',
                    'type': std['type'],
                    'ip': 'N/A'
                })
    
    except Exception as e:
        print(f"âš ï¸ ç½‘æ®µæ£€æµ‹å¼‚å¸¸: {e}")
        # é™çº§æ–¹æ¡ˆ: è¿”å›æ ‡å‡†ç§ç½‘æ®µ
        return STANDARD_PRIVATE
    
    return networks

def check_network_status(network):
    """
    æ£€æŸ¥æŸä¸ªç½‘æ®µæ˜¯å¦å·²æ”¾è¡Œ
    è¿”å›: True (å·²æ”¾è¡Œ) / False (æœªæ”¾è¡Œ)
    """
    try:
        # è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦
        escaped_network = network.replace('.', r'\.')
        cmd = f"iptables -S INPUT | grep -E '^-A INPUT -s {escaped_network} -j ACCEPT$'"
        result = subprocess.getoutput(cmd)
        return bool(result.strip())
    except:
        return False

def toggle_network_access(network):
    """
    åˆ‡æ¢ç½‘æ®µçš„è®¿é—®æƒé™
    """
    try:
        is_allowed = check_network_status(network)
        
        if is_allowed:
            # å½“å‰å·²æ”¾è¡Œ â†’ æ‹’ç»
            subprocess.run(f"iptables -D INPUT -s {network} -j ACCEPT", shell=True, check=True)
            return f"âŒ å·²æ‹’ç»ç½‘æ®µ `{network}`"
        else:
            # å½“å‰å·²æ‹’ç» â†’ æ”¾è¡Œ
            subprocess.run(f"iptables -I INPUT 1 -s {network} -j ACCEPT", shell=True, check=True)
            return f"âœ… å·²æ”¾è¡Œç½‘æ®µ `{network}` (æ‰€æœ‰ç«¯å£)"
    
    except Exception as e:
        return f"âŒ æ“ä½œå¤±è´¥: {str(e)}"

def init_default_networks():
    """
    åˆå§‹åŒ–é»˜è®¤ç½‘æ®µè§„åˆ™
    åœ¨ç³»ç»Ÿå¯åŠ¨æ—¶è°ƒç”¨,ç¡®ä¿æ ‡å‡†ç§ç½‘å’ŒDockerç½‘æ®µé»˜è®¤æ”¾è¡Œ
    """
    networks = detect_local_networks()
    
    for net_info in networks:
        network = net_info['network']
        net_type = net_info['type']
        
        # æ ‡å‡†ç§ç½‘ã€Dockerã€VPNã€æœ¬åœ°å›ç¯ é»˜è®¤æ”¾è¡Œ
        if net_type in ['standard', 'docker', 'vpn', 'loopback', 'current']:
            if not check_network_status(network):
                try:
                    subprocess.run(
                        f"iptables -I INPUT 1 -s {network} -j ACCEPT",
                        shell=True,
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
                except:
                    pass

def get_network_manage_menu():
    """
    æ„å»ºå†…ç½‘è®¿é—®ç®¡ç†èœå•
    """
    networks = detect_local_networks()
    
    # æŒ‰ç±»å‹æ’åº: current > docker > vpn > standard > loopback
    type_priority = {'current': 1, 'docker': 2, 'vpn': 3, 'standard': 4, 'loopback': 5}
    networks.sort(key=lambda x: type_priority.get(x['type'], 99))
    
    txt = (f"ğŸ  **å†…ç½‘è®¿é—®æ§åˆ¶**\n"
           f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
           f"ğŸ“¡ æ£€æµ‹åˆ° {len(networks)} ä¸ªç½‘æ®µ:\n\n")
    
    kb = []
    
    for net_info in networks:
        network = net_info['network']
        iface = net_info['interface']
        net_type = net_info['type']
        ip = net_info.get('ip', 'N/A')
        
        # æ£€æŸ¥çŠ¶æ€
        is_allowed = check_network_status(network)
        
        # å›¾æ ‡
        if is_allowed:
            icon = "âœ…"
        else:
            icon = "âŒ"
        
        # ç±»å‹æ ‡ç­¾
        if net_type == 'current':
            type_label = "å½“å‰ç½‘æ®µ"
        elif net_type == 'docker':
            type_label = "Docker"
        elif net_type == 'vpn':
            type_label = "VPN"
        elif net_type == 'loopback':
            type_label = "æœ¬åœ°"
        elif net_type == 'standard':
            type_label = "æ ‡å‡†ç§ç½‘"
        else:
            type_label = "å…¶ä»–"
        
        # è¯¦æƒ…æ–‡æœ¬
        if ip != 'N/A':
            txt += f"{icon} `{network}` ({type_label})\n   ç½‘å¡: {iface} | IP: {ip}\n\n"
        else:
            txt += f"{icon} `{network}` ({type_label})\n\n"
        
        # æŒ‰é’®
        kb.append([InlineKeyboardButton(
            f"{icon} {network} ({type_label})",
            callback_data=f"net_lan_{network.replace('/', '_')}"
        )])
    
    txt += (f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"ğŸ’¡ **è¯´æ˜**:\n"
            f"â€¢ âœ… = å·²æ”¾è¡Œ (æ‰€æœ‰ç«¯å£å¯è®¿é—®)\n"
            f"â€¢ âŒ = å·²æ‹’ç»\n"
            f"â€¢ æ ‡å‡†ç§ç½‘é»˜è®¤å¼€å¯\n"
            f"â€¢ Docker/VPN è‡ªåŠ¨è¯†åˆ«å¹¶æ”¾è¡Œ")
    
    kb.append([InlineKeyboardButton("ğŸ”„ é‡æ–°æ£€æµ‹", callback_data="net_lan_refresh")])
    kb.append([InlineKeyboardButton("â• æ‰‹åŠ¨æ·»åŠ ç½‘æ®µ", callback_data="net_lan_add")])
    kb.append([InlineKeyboardButton("ğŸ”™ è¿”å›ç«¯å£é…ç”µç®±", callback_data="net_ports")])
    
    return txt, InlineKeyboardMarkup(kb)

# ===============================
# ğŸšª ç«¯å£æ§åˆ¶ (ä¿æŒåŸæœ‰é€»è¾‘)
# ===============================

def build_port_menu():
    """æ„å»ºç«¯å£æ§åˆ¶èœå•"""
    sp = get_ssh_port()
    sc = "ACCEPT" in subprocess.getoutput(f"iptables -L INPUT -n | grep 'dpt:{sp}'")
    pc = "DROP" in subprocess.getoutput("iptables -L INPUT -n | grep 'icmp'")
    fw_res = subprocess.getoutput(r"iptables -S INPUT | grep '\-P INPUT'")
    is_wl = "DROP" in fw_res
    
    biz = load_ports()
    btns = []
    for p, i in biz.items():
        status = "ğŸŸ¢" if f"dpt:{p}" in subprocess.getoutput("iptables -L INPUT -n") else "ğŸ”´"
        desc = i.get('desc', 'ç«¯å£')
        btns.append(InlineKeyboardButton(f"{status} {desc}({p})", callback_data=f"net_biz_{p}"))
    
    kb = [
        [InlineKeyboardButton(f"{'ğŸŸ¢' if sc else 'ğŸ”´'} SSHå…¬ç½‘ ({sp})", callback_data=f"net_ssh_{sp}")],
        [InlineKeyboardButton(f"{'ğŸ”´' if pc else 'ğŸŸ¢'} å…è®¸ Ping", callback_data="net_ping")]
    ]
    kb.extend([btns[i:i+2] for i in range(0, len(btns), 2)])
    
    # âœ… æ–°å¢: å†…ç½‘è®¿é—®ç®¡ç†æŒ‰é’®
    kb.append([InlineKeyboardButton("ğŸ  å†…ç½‘è®¿é—®ç®¡ç†", callback_data="net_lan_manage")])
    
    kb.append([
        InlineKeyboardButton("ğŸ›¡ï¸ æ¿€æ´»ç™½åå•" if not is_wl else "ğŸ›¡ï¸ ç™½åå•æ¨¡å¼ âœ…", callback_data="net_reset"), 
        InlineKeyboardButton("ğŸ”“ å¼€æ”¾æ‰€æœ‰ç«¯å£" if is_wl else "ğŸ”“ å…¨å¼€æ”¾ âœ…", callback_data="net_rescue")
    ])
    kb.append([
        InlineKeyboardButton("â• æ·»åŠ ç«¯å£", callback_data="net_add"), 
        InlineKeyboardButton("â– åˆ é™¤ç«¯å£", callback_data="net_del")
    ])
    kb.append([InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="back")])
    
    return (
        "ğŸšª **ç«¯å£é…ç”µç®±**\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        "ğŸŸ¢=å¼€æ”¾ | ğŸ”´=å…³é—­\n"
        "ğŸ’¡ **æç¤º**: å†…ç½‘è®¿é—®è¯·è¿›å…¥ ğŸ å†…ç½‘ç®¡ç†\n\n"
        "ğŸ›¡ï¸ **ç™½åå•æ¨¡å¼**: å¼€å¯å,æœªåˆ—å‡ºçš„ç«¯å£å°†æ— æ³•è®¿é—® (SSHé™¤å¤–)ã€‚"
    ), InlineKeyboardMarkup(kb)

def toggle_port(port):
    """åˆ‡æ¢ç«¯å£å¼€å…³ (ä»…æ§åˆ¶å¤–ç½‘)"""
    try:
        check = subprocess.getoutput(f"iptables -C INPUT -p tcp --dport {port} -j ACCEPT 2>&1")
        if "Bad rule" in check or "No such file" in check:
            subprocess.run(f"iptables -I INPUT -p tcp --dport {port} -j ACCEPT", shell=True)
            subprocess.run(f"iptables -I INPUT -p udp --dport {port} -j ACCEPT", shell=True)
            return f"ğŸŸ¢ ç«¯å£ {port} å·²å¼€æ”¾"
        else:
            subprocess.run(f"iptables -D INPUT -p tcp --dport {port} -j ACCEPT", shell=True)
            try:
                subprocess.run(f"iptables -D INPUT -p udp --dport {port} -j ACCEPT", shell=True)
            except:
                pass
            return f"ğŸ”´ ç«¯å£ {port} å·²å…³é—­"
    except Exception as e:
        return f"âŒ æ“ä½œå¤±è´¥: {e}"

def add_port_rule(port_str):
    """æ·»åŠ ç«¯å£è§„åˆ™"""
    try:
        parts = port_str.split()
        port = parts[0]
        desc = parts[1] if len(parts) > 1 else "è‡ªå®šä¹‰"
        
        if not port.isdigit():
            return "âŒ ç«¯å£å¿…é¡»æ˜¯æ•°å­—"
        
        biz = load_ports()
        biz[port] = {'desc': desc}
        save_ports(biz)
        
        subprocess.run(f"iptables -I INPUT -p tcp --dport {port} -j ACCEPT", shell=True)
        subprocess.run(f"iptables -I INPUT -p udp --dport {port} -j ACCEPT", shell=True)
        
        return f"âœ… ç«¯å£ {port} ({desc}) å·²æ·»åŠ å¹¶å¼€æ”¾"
    except Exception as e:
        return f"âŒ æ·»åŠ å¤±è´¥: {e}"

def del_port_rule(port):
    """åˆ é™¤ç«¯å£è§„åˆ™"""
    try:
        biz = load_ports()
        if port not in biz:
            return "âš ï¸ ç«¯å£ä¸åœ¨åˆ—è¡¨ä¸­"
        
        del biz[port]
        save_ports(biz)
        
        subprocess.run(f"iptables -D INPUT -p tcp --dport {port} -j ACCEPT", shell=True)
        try:
            subprocess.run(f"iptables -D INPUT -p udp --dport {port} -j ACCEPT", shell=True)
        except:
            pass
        
        return f"ğŸ—‘ï¸ ç«¯å£ {port} å·²ç§»é™¤"
    except Exception as e:
        return f"âŒ åˆ é™¤å¤±è´¥: {e}"

def toggle_ssh(port):
    """åˆ‡æ¢ SSH ç«¯å£å¼€å…³"""
    check = subprocess.getoutput(f"iptables -C INPUT -p tcp --dport {port} -j ACCEPT 2>&1")
    if "Bad" in check:
        subprocess.run(f"iptables -I INPUT -p tcp --dport {port} -j ACCEPT", shell=True)
        return "ğŸŸ¢ SSH ç«¯å£å·²å…è®¸"
    else:
        subprocess.run(f"iptables -D INPUT -p tcp --dport {port} -j ACCEPT", shell=True)
        return "ğŸ”´ SSH ç«¯å£å·²ä»ç™½åå•ç§»é™¤"

def toggle_ping():
    """åˆ‡æ¢ Ping å¼€å…³"""
    check = subprocess.getoutput("iptables -C INPUT -p icmp -j DROP 2>&1")
    if "Bad" in check:
        subprocess.run("iptables -I INPUT -p icmp -j DROP", shell=True)
        return "ğŸ”´ å·²ç¦æ­¢ Ping (éšèº«æ¨¡å¼)"
    else:
        subprocess.run("iptables -D INPUT -p icmp -j DROP", shell=True)
        return "ğŸŸ¢ å·²å…è®¸ Ping"

def set_whitelist_mode(enable=True):
    """è®¾ç½®ç™½åå•æ¨¡å¼"""
    try:
        if enable:
            sp = get_ssh_port()
            subprocess.run(f"iptables -I INPUT -p tcp --dport {sp} -j ACCEPT", shell=True)
            subprocess.run("iptables -I INPUT -i lo -j ACCEPT", shell=True)
            subprocess.run("iptables -I INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT", shell=True)
            
            # âœ… ç¡®ä¿å†…ç½‘è§„åˆ™ä¼˜å…ˆ
            init_default_networks()
            
            subprocess.run("iptables -P INPUT DROP", shell=True)
            return "ğŸ›¡ï¸ ç™½åå•æ¨¡å¼å·²æ¿€æ´»!"
        else:
            subprocess.run("iptables -P INPUT ACCEPT", shell=True)
            return "ğŸ”“ é˜²ç«å¢™å·²å…¨å¼€æ”¾"
    except Exception as e:
        return f"âŒ è®¾ç½®å¤±è´¥: {e}"

# -*- coding: utf-8 -*-
# modules/network.py (V6.0.0 å†…ç½‘æ™ºèƒ½ç®¡ç†ç‰ˆ)
import subprocess, re, os, requests, math, ipaddress, netifaces
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from config import load_ports, save_ports, SSH_FILE, load_config

# --- è¾…åŠ©: IP ä¿¡æ¯ç¼“å­˜ ---
IP_CACHE = {}

def get_flag_emoji(country_code):
    """å°†å›½å®¶ä»£ç è½¬æ¢ä¸ºæ——å¸œ Emoji"""
    if not country_code or len(country_code) != 2:
        return "ğŸ‡ºğŸ‡³"
    return "".join([chr(ord(c.upper()) + 127397) for c in country_code])

def get_ip_detail(ip):
    """è·å– IP è¯¦ç»†ä¿¡æ¯ (å¸¦ç¼“å­˜)"""
    query_ip = ip.split('/')[0] if '/' in ip else ip
    
    if query_ip in IP_CACHE:
        return IP_CACHE[query_ip]
    
    try:
        url = f"http://ip-api.com/json/{query_ip}?fields=status,message,countryCode,isp"
        r = requests.get(url, timeout=1.5).json()
        
        if r.get('status') == 'success':
            flag = get_flag_emoji(r.get('countryCode'))
            isp = r.get('isp', 'Unknown')
            if len(isp) > 15:
                isp = isp[:15] + "..."
            info = {'flag': flag, 'isp': isp, 'code': r.get('countryCode')}
        else:
            info = {'flag': "ğŸ´â€â˜ ï¸", 'isp': "Private", 'code': "XX"}
        
        IP_CACHE[query_ip] = info
        return info
    except:
        return {'flag': "ğŸ“¡", 'isp': "Timeout", 'code': "XX"}

def get_ssh_port():
    """å¢å¼ºçš„ SSH ç«¯å£æ£€æµ‹"""
    try:
        out = subprocess.getoutput("sshd -T 2>/dev/null | grep '^port '").strip()
        if out and 'port' in out.lower():
            port = out.split()[-1]
            if port.isdigit():
                return port
    except:
        pass
    
    try:
        if os.path.exists(SSH_FILE):
            out = subprocess.getoutput(f"grep -i '^Port ' {SSH_FILE}").strip()
            if out:
                port = out.split()[-1]
                if port.isdigit():
                    return port
    except:
        pass
    
    return "22"

# ===============================
# ğŸ  å†…ç½‘æ™ºèƒ½ç®¡ç† (æ ¸å¿ƒæ–°å¢)
# ===============================

def detect_local_networks():
    """
    æ™ºèƒ½æ£€æµ‹æœ¬æœºæ‰€æœ‰ç½‘æ®µ
    è¿”å›: [{'network': '192.168.1.0/24', 'interface': 'eth0', 'type': 'current', 'ip': '192.168.1.100'}]
    """
    networks = []
    detected_networks = set()
    
    # æ ‡å‡†ç§ç½‘æ®µ
    STANDARD_PRIVATE = [
        {'network': '10.0.0.0/8', 'type': 'standard'},
        {'network': '172.16.0.0/12', 'type': 'standard'},
        {'network': '192.168.0.0/16', 'type': 'standard'},
        {'network': '127.0.0.0/8', 'type': 'loopback'}
    ]
    
    try:
        # éå†æ‰€æœ‰ç½‘å¡
        for iface in netifaces.interfaces():
            try:
                addrs = netifaces.ifaddresses(iface)
                if netifaces.AF_INET not in addrs:
                    continue
                
                for addr in addrs[netifaces.AF_INET]:
                    ip = addr.get('addr')
                    netmask = addr.get('netmask')
                    
                    if not ip or not netmask:
                        continue
                    
                    # è·³è¿‡éç§ç½‘IP
                    if not ipaddress.ip_address(ip).is_private and ip != '127.0.0.1':
                        continue
                    
                    # è®¡ç®—ç½‘æ®µ
                    network = ipaddress.IPv4Network(f"{ip}/{netmask}", strict=False)
                    network_str = str(network)
                    
                    # é¿å…é‡å¤
                    if network_str in detected_networks:
                        continue
                    
                    detected_networks.add(network_str)
                    
                    # åˆ¤æ–­ç±»å‹
                    if 'docker' in iface.lower():
                        net_type = 'docker'
                    elif 'tun' in iface.lower() or 'tap' in iface.lower() or 'vpn' in iface.lower():
                        net_type = 'vpn'
                    elif 'tailscale' in iface.lower() or 'wg' in iface.lower():
                        net_type = 'vpn'
                    elif ip.startswith('127.'):
                        net_type = 'loopback'
                    else:
                        net_type = 'current'
                    
                    networks.append({
                        'network': network_str,
                        'interface': iface,
                        'type': net_type,
                        'ip': ip
                    })
            except:
                continue
        
        # æ·»åŠ æ ‡å‡†ç§ç½‘æ®µ (å¦‚æœæœªæ£€æµ‹åˆ°)
        for std in STANDARD_PRIVATE:
            if std['network'] not in detected_networks:
                networks.append({
                    'network': std['network'],
                    'interface': 'N/A',
                    'type': std['type'],
                    'ip': 'N/A'
                })
    
    except Exception as e:
        print(f"âš ï¸ ç½‘æ®µæ£€æµ‹å¼‚å¸¸: {e}")
        # é™çº§æ–¹æ¡ˆ: è¿”å›æ ‡å‡†ç§ç½‘æ®µ
        return STANDARD_PRIVATE
    
    return networks

def check_network_status(network):
    """
    æ£€æŸ¥æŸä¸ªç½‘æ®µæ˜¯å¦å·²æ”¾è¡Œ
    è¿”å›: True (å·²æ”¾è¡Œ) / False (æœªæ”¾è¡Œ)
    """
    try:
        # è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦
        escaped_network = network.replace('.', r'\.')
        cmd = f"iptables -S INPUT | grep -E '^-A INPUT -s {escaped_network} -j ACCEPT$'"
        result = subprocess.getoutput(cmd)
        return bool(result.strip())
    except:
        return False

def toggle_network_access(network):
    """
    åˆ‡æ¢ç½‘æ®µçš„è®¿é—®æƒé™
    """
    try:
        is_allowed = check_network_status(network)
        
        if is_allowed:
            # å½“å‰å·²æ”¾è¡Œ â†’ æ‹’ç»
            subprocess.run(f"iptables -D INPUT -s {network} -j ACCEPT", shell=True, check=True)
            return f"âŒ å·²æ‹’ç»ç½‘æ®µ `{network}`"
        else:
            # å½“å‰å·²æ‹’ç» â†’ æ”¾è¡Œ
            subprocess.run(f"iptables -I INPUT 1 -s {network} -j ACCEPT", shell=True, check=True)
            return f"âœ… å·²æ”¾è¡Œç½‘æ®µ `{network}` (æ‰€æœ‰ç«¯å£)"
    
    except Exception as e:
        return f"âŒ æ“ä½œå¤±è´¥: {str(e)}"

def init_default_networks():
    """
    åˆå§‹åŒ–é»˜è®¤ç½‘æ®µè§„åˆ™
    åœ¨ç³»ç»Ÿå¯åŠ¨æ—¶è°ƒç”¨,ç¡®ä¿æ ‡å‡†ç§ç½‘å’ŒDockerç½‘æ®µé»˜è®¤æ”¾è¡Œ
    """
    networks = detect_local_networks()
    
    for net_info in networks:
        network = net_info['network']
        net_type = net_info['type']
        
        # æ ‡å‡†ç§ç½‘ã€Dockerã€VPNã€æœ¬åœ°å›ç¯ é»˜è®¤æ”¾è¡Œ
        if net_type in ['standard', 'docker', 'vpn', 'loopback', 'current']:
            if not check_network_status(network):
                try:
                    subprocess.run(
                        f"iptables -I INPUT 1 -s {network} -j ACCEPT",
                        shell=True,
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
                except:
                    pass

def get_network_manage_menu():
    """
    æ„å»ºå†…ç½‘è®¿é—®ç®¡ç†èœå•
    """
    networks = detect_local_networks()
    
    # æŒ‰ç±»å‹æ’åº: current > docker > vpn > standard > loopback
    type_priority = {'current': 1, 'docker': 2, 'vpn': 3, 'standard': 4, 'loopback': 5}
    networks.sort(key=lambda x: type_priority.get(x['type'], 99))
    
    txt = (f"ğŸ  **å†…ç½‘è®¿é—®æ§åˆ¶**\n"
           f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
           f"ğŸ“¡ æ£€æµ‹åˆ° {len(networks)} ä¸ªç½‘æ®µ:\n\n")
    
    kb = []
    
    for net_info in networks:
        network = net_info['network']
        iface = net_info['interface']
        net_type = net_info['type']
        ip = net_info.get('ip', 'N/A')
        
        # æ£€æŸ¥çŠ¶æ€
        is_allowed = check_network_status(network)
        
        # å›¾æ ‡
        if is_allowed:
            icon = "âœ…"
        else:
            icon = "âŒ"
        
        # ç±»å‹æ ‡ç­¾
        if net_type == 'current':
            type_label = "å½“å‰ç½‘æ®µ"
        elif net_type == 'docker':
            type_label = "Docker"
        elif net_type == 'vpn':
            type_label = "VPN"
        elif net_type == 'loopback':
            type_label = "æœ¬åœ°"
        elif net_type == 'standard':
            type_label = "æ ‡å‡†ç§ç½‘"
        else:
            type_label = "å…¶ä»–"
        
        # è¯¦æƒ…æ–‡æœ¬
        if ip != 'N/A':
            txt += f"{icon} `{network}` ({type_label})\n   ç½‘å¡: {iface} | IP: {ip}\n\n"
        else:
            txt += f"{icon} `{network}` ({type_label})\n\n"
        
        # æŒ‰é’®
        kb.append([InlineKeyboardButton(
            f"{icon} {network} ({type_label})",
            callback_data=f"net_lan_{network.replace('/', '_')}"
        )])
    
    txt += (f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
            f"ğŸ’¡ **è¯´æ˜**:\n"
            f"â€¢ âœ… = å·²æ”¾è¡Œ (æ‰€æœ‰ç«¯å£å¯è®¿é—®)\n"
            f"â€¢ âŒ = å·²æ‹’ç»\n"
            f"â€¢ æ ‡å‡†ç§ç½‘é»˜è®¤å¼€å¯\n"
            f"â€¢ Docker/VPN è‡ªåŠ¨è¯†åˆ«å¹¶æ”¾è¡Œ")
    
    kb.append([InlineKeyboardButton("ğŸ”„ é‡æ–°æ£€æµ‹", callback_data="net_lan_refresh")])
    kb.append([InlineKeyboardButton("â• æ‰‹åŠ¨æ·»åŠ ç½‘æ®µ", callback_data="net_lan_add")])
    kb.append([InlineKeyboardButton("ğŸ”™ è¿”å›ç«¯å£é…ç”µç®±", callback_data="net_ports")])
    
    return txt, InlineKeyboardMarkup(kb)

# ===============================
# ğŸšª ç«¯å£æ§åˆ¶ (ä¿æŒåŸæœ‰é€»è¾‘)
# ===============================

def build_port_menu():
    """æ„å»ºç«¯å£æ§åˆ¶èœå•"""
    sp = get_ssh_port()
    sc = "ACCEPT" in subprocess.getoutput(f"iptables -L INPUT -n | grep 'dpt:{sp}'")
    pc = "DROP" in subprocess.getoutput("iptables -L INPUT -n | grep 'icmp'")
    fw_res = subprocess.getoutput(r"iptables -S INPUT | grep '\-P INPUT'")
    is_wl = "DROP" in fw_res
    
    biz = load_ports()
    btns = []
    for p, i in biz.items():
        status = "ğŸŸ¢" if f"dpt:{p}" in subprocess.getoutput("iptables -L INPUT -n") else "ğŸ”´"
        desc = i.get('desc', 'ç«¯å£')
        btns.append(InlineKeyboardButton(f"{status} {desc}({p})", callback_data=f"net_biz_{p}"))
    
    kb = [
        [InlineKeyboardButton(f"{'ğŸŸ¢' if sc else 'ğŸ”´'} SSHå…¬ç½‘ ({sp})", callback_data=f"net_ssh_{sp}")],
        [InlineKeyboardButton(f"{'ğŸ”´' if pc else 'ğŸŸ¢'} å…è®¸ Ping", callback_data="net_ping")]
    ]
    kb.extend([btns[i:i+2] for i in range(0, len(btns), 2)])
    
    # âœ… æ–°å¢: å†…ç½‘è®¿é—®ç®¡ç†æŒ‰é’®
    kb.append([InlineKeyboardButton("ğŸ  å†…ç½‘è®¿é—®ç®¡ç†", callback_data="net_lan_manage")])
    
    kb.append([
        InlineKeyboardButton("ğŸ›¡ï¸ æ¿€æ´»ç™½åå•" if not is_wl else "ğŸ›¡ï¸ ç™½åå•æ¨¡å¼ âœ…", callback_data="net_reset"), 
        InlineKeyboardButton("ğŸ”“ å¼€æ”¾æ‰€æœ‰ç«¯å£" if is_wl else "ğŸ”“ å…¨å¼€æ”¾ âœ…", callback_data="net_rescue")
    ])
    kb.append([
        InlineKeyboardButton("â• æ·»åŠ ç«¯å£", callback_data="net_add"), 
        InlineKeyboardButton("â– åˆ é™¤ç«¯å£", callback_data="net_del")
    ])
    kb.append([InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="back")])
    
    return (
        "ğŸšª **ç«¯å£é…ç”µç®±**\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        "ğŸŸ¢=å¼€æ”¾ | ğŸ”´=å…³é—­\n"
        "ğŸ’¡ **æç¤º**: å†…ç½‘è®¿é—®è¯·è¿›å…¥ ğŸ å†…ç½‘ç®¡ç†\n\n"
        "ğŸ›¡ï¸ **ç™½åå•æ¨¡å¼**: å¼€å¯å,æœªåˆ—å‡ºçš„ç«¯å£å°†æ— æ³•è®¿é—® (SSHé™¤å¤–)ã€‚"
    ), InlineKeyboardMarkup(kb)

def toggle_port(port):
    """åˆ‡æ¢ç«¯å£å¼€å…³ (ä»…æ§åˆ¶å¤–ç½‘)"""
    try:
        check = subprocess.getoutput(f"iptables -C INPUT -p tcp --dport {port} -j ACCEPT 2>&1")
        if "Bad rule" in check or "No such file" in check:
            subprocess.run(f"iptables -I INPUT -p tcp --dport {port} -j ACCEPT", shell=True)
            subprocess.run(f"iptables -I INPUT -p udp --dport {port} -j ACCEPT", shell=True)
            return f"ğŸŸ¢ ç«¯å£ {port} å·²å¼€æ”¾"
        else:
            subprocess.run(f"iptables -D INPUT -p tcp --dport {port} -j ACCEPT", shell=True)
            try:
                subprocess.run(f"iptables -D INPUT -p udp --dport {port} -j ACCEPT", shell=True)
            except:
                pass
            return f"ğŸ”´ ç«¯å£ {port} å·²å…³é—­"
    except Exception as e:
        return f"âŒ æ“ä½œå¤±è´¥: {e}"

def add_port_rule(port_str):
    """æ·»åŠ ç«¯å£è§„åˆ™"""
    try:
        parts = port_str.split()
        port = parts[0]
        desc = parts[1] if len(parts) > 1 else "è‡ªå®šä¹‰"
        
        if not port.isdigit():
            return "âŒ ç«¯å£å¿…é¡»æ˜¯æ•°å­—"
        
        biz = load_ports()
        biz[port] = {'desc': desc}
        save_ports(biz)
        
        subprocess.run(f"iptables -I INPUT -p tcp --dport {port} -j ACCEPT", shell=True)
        subprocess.run(f"iptables -I INPUT -p udp --dport {port} -j ACCEPT", shell=True)
        
        return f"âœ… ç«¯å£ {port} ({desc}) å·²æ·»åŠ å¹¶å¼€æ”¾"
    except Exception as e:
        return f"âŒ æ·»åŠ å¤±è´¥: {e}"

def del_port_rule(port):
    """åˆ é™¤ç«¯å£è§„åˆ™"""
    try:
        biz = load_ports()
        if port not in biz:
            return "âš ï¸ ç«¯å£ä¸åœ¨åˆ—è¡¨ä¸­"
        
        del biz[port]
        save_ports(biz)
        
        subprocess.run(f"iptables -D INPUT -p tcp --dport {port} -j ACCEPT", shell=True)
        try:
            subprocess.run(f"iptables -D INPUT -p udp --dport {port} -j ACCEPT", shell=True)
        except:
            pass
        
        return f"ğŸ—‘ï¸ ç«¯å£ {port} å·²ç§»é™¤"
    except Exception as e:
        return f"âŒ åˆ é™¤å¤±è´¥: {e}"

def toggle_ssh(port):
    """åˆ‡æ¢ SSH ç«¯å£å¼€å…³"""
    check = subprocess.getoutput(f"iptables -C INPUT -p tcp --dport {port} -j ACCEPT 2>&1")
    if "Bad" in check:
        subprocess.run(f"iptables -I INPUT -p tcp --dport {port} -j ACCEPT", shell=True)
        return "ğŸŸ¢ SSH ç«¯å£å·²å…è®¸"
    else:
        subprocess.run(f"iptables -D INPUT -p tcp --dport {port} -j ACCEPT", shell=True)
        return "ğŸ”´ SSH ç«¯å£å·²ä»ç™½åå•ç§»é™¤"

def toggle_ping():
    """åˆ‡æ¢ Ping å¼€å…³"""
    check = subprocess.getoutput("iptables -C INPUT -p icmp -j DROP 2>&1")
    if "Bad" in check:
        subprocess.run("iptables -I INPUT -p icmp -j DROP", shell=True)
        return "ğŸ”´ å·²ç¦æ­¢ Ping (éšèº«æ¨¡å¼)"
    else:
        subprocess.run("iptables -D INPUT -p icmp -j DROP", shell=True)
        return "ğŸŸ¢ å·²å…è®¸ Ping"

def set_whitelist_mode(enable=True):
    """è®¾ç½®ç™½åå•æ¨¡å¼"""
    try:
        if enable:
            sp = get_ssh_port()
            subprocess.run(f"iptables -I INPUT -p tcp --dport {sp} -j ACCEPT", shell=True)
            subprocess.run("iptables -I INPUT -i lo -j ACCEPT", shell=True)
            subprocess.run("iptables -I INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT", shell=True)
            
            # âœ… ç¡®ä¿å†…ç½‘è§„åˆ™ä¼˜å…ˆ
            init_default_networks()
            
            subprocess.run("iptables -P INPUT DROP", shell=True)
            return "ğŸ›¡ï¸ ç™½åå•æ¨¡å¼å·²æ¿€æ´»!"
        else:
            subprocess.run("iptables -P INPUT ACCEPT", shell=True)
            return "ğŸ”“ é˜²ç«å¢™å·²å…¨å¼€æ”¾"
    except Exception as e:
        return f"âŒ è®¾ç½®å¤±è´¥: {e}"

# ===============================
# ğŸ“Š æµé‡å¯è§†åŒ– (å¢å¼ºç‰ˆ)
# ===============================

def generate_traffic_bar(value_gb, max_val):
    """ç”Ÿæˆæµé‡è¿›åº¦æ¡"""
    if max_val == 0:
        max_val = 1
    percent = min(value_gb / max_val, 1.0)
    filled = int(percent * 10)
    
    if value_gb < 0.1:
        icon = "â–‘"
    elif value_gb < 0.5:
        icon = "â–’"  
    elif value_gb < 1:
        icon = "â–“"
    else:
        icon = "â–ˆ"
    
    return icon * filled + "â–‘" * (10 - filled)

def parse_traffic_value(traffic_str):
    """è§£ææµé‡å­—ç¬¦ä¸²ä¸º GB æ•°å€¼"""
    try:
        parts = traffic_str.split()
        val = float(parts[0])
        unit = parts[1].lower()
        
        if 'gib' in unit or 'gb' in unit:
            return val
        elif 'mib' in unit or 'mb' in unit:
            return val / 1024
        elif 'kib' in unit or 'kb' in unit:
            return val / 1048576
        else:
            return val
    except:
        return 0.0

def get_traffic_hourly():
    """è·å–å°æ—¶æµé‡è¶‹åŠ¿"""
    conf = load_config()
    raw = subprocess.getoutput("vnstat -h 24")
    lines = raw.split('\n')
    max_traffic = 0.01
    temp_data = []
    
    for line in lines:
        match = re.search(r'(\d{2}:\d{2})\s+([\d\.]+\s+\w+iB)\s+\|\s+([\d\.]+\s+\w+iB)\s+\|\s+([\d\.]+\s+\w+iB)', line)
        if match:
            time_str, rx, tx, total = match.group(1), match.group(2), match.group(3), match.group(4)
            total_gb = parse_traffic_value(total)
            max_traffic = max(max_traffic, total_gb)
            temp_data.append({
                'time': time_str, 
                'rx': rx, 
                'tx': tx, 
                'total': total, 
                'total_gb': total_gb
            })
    
    hourly_data = []
    for data in temp_data:
        bar = generate_traffic_bar(data['total_gb'], max_traffic)
        
        if data['total_gb'] > 1:
            emoji = "ğŸ”¥"
        elif data['total_gb'] > 0.5:
            emoji = "ğŸŸ "
        elif data['total_gb'] > 0.1:
            emoji = "ğŸŸ¡"
        else:
            emoji = "ğŸŸ¢"
        
        hourly_data.append(f"`{data['time']}` {bar} {emoji} `{data['total'].split()[0]}{data['total'].split()[1][0]}`")
    
    today_total = sum([d['total_gb'] for d in temp_data])
    
    res = f"ğŸ“Š **æµé‡å®¡è®¡ Â· 24H å¯è§†åŒ–è¶‹åŠ¿**\nğŸŒ èŠ‚ç‚¹: `{conf.get('server_remark', 'MyVPS')}`\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
    res += "\n".join(hourly_data[-12:]) if hourly_data else "ğŸ”­ æš‚æ— æ•°æ®"
    res += f"\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ“Š ä»Šæ—¥ç´¯è®¡: `{today_total:.2f} GB`\nğŸ’¡ ğŸŸ¢<100M | ğŸŸ¡<500M | ğŸŸ <1G | ğŸ”¥>1G"
    
    kb = [
        [InlineKeyboardButton("â³ å°æ—¶è¶‹åŠ¿ (ç°)", callback_data="none"), 
         InlineKeyboardButton("ğŸ“… 30æ—¥è´¦å•", callback_data="sys_traffic_d"), 
         InlineKeyboardButton("ğŸ³ å®æ—¶ç›‘æ§", callback_data="sys_traffic_r")],
        [InlineKeyboardButton("ğŸ“ˆ Dockeræµé‡", callback_data="sys_traffic_rank")],
        [InlineKeyboardButton("ğŸ”„ åˆ·æ–°", callback_data="sys_traffic_h"), 
         InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="back")]
    ]
    
    return res, InlineKeyboardMarkup(kb)

def get_traffic_history():
    """è·å–æµé‡å†å²è´¦å•"""
    conf = load_config()
    raw = subprocess.getoutput("vnstat -d 30")
    lines = raw.split('\n')
    history_blocks = []
    
    for line in lines:
        match = re.search(r'(\d{4}-\d{2}-\d{2}|\d{2}/\d{2}/\d{2})\s+([\d\.]+\s+\w+iB)\s+\|\s+([\d\.]+\s+\w+iB)\s+\|\s+([\d\.]+\s+\w+iB)', line)
        if match:
            date_str, rx, tx, total = match.group(1), match.group(2), match.group(3), match.group(4)
            block = f"ğŸ•’ `{date_str}`\nâ¬‡ï¸:`{rx.strip()}`, â¬†ï¸:`{tx.strip()}` ğŸ’°: `{total.strip()}`"
            history_blocks.append(block)

    res = f"ğŸ“Š **æµé‡å®¡è®¡ Â· 30æ—¥å†å²è´¦å•**\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
    res += "\n\n".join(history_blocks[-15:]) if history_blocks else "ğŸ”­ æš‚æ— å†å²è´¦å•"
    res += f"\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ“… ç»“ç®—æ—¥: æ¯æœˆ `{conf.get('billing_day', 1)}` å·"
    
    kb = [
        [InlineKeyboardButton("â³ å°æ—¶è¶‹åŠ¿", callback_data="sys_traffic_h"), 
         InlineKeyboardButton("ğŸ“… 30æ—¥è´¦å• (ç°)", callback_data="none"), 
         InlineKeyboardButton("ğŸ³ å®æ—¶ç›‘æ§", callback_data="sys_traffic_r")],
        [InlineKeyboardButton("ğŸ”„ åˆ·æ–°", callback_data="sys_traffic_d"), 
         InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="back")]
    ]
    
    return res, InlineKeyboardMarkup(kb)

def get_traffic_realtime():
    """è·å–å®æ—¶æµé‡ç›‘æ§"""
    # Docker å®¹å™¨æµé‡
    dk_raw = subprocess.getoutput(r"docker stats --no-stream --format '{{.Name}}|{{.NetIO}}'")
    dk_usage = [f"ğŸ³ {line.split('|')[0].ljust(12)} | {line.split('|')[1]}" 
                for line in dk_raw.split('\n') if '|' in line]
    
    # nethogs è¿›ç¨‹ç›‘æ§ (ç§»é™¤sudo)
    nethogs_cmd = "timeout 3 nethogs -t -c 2 2>/dev/null || echo 'nethogs_unavailable'"
    nethogs_raw = subprocess.getoutput(nethogs_cmd)
    
    process_dict = {}
    
    if 'nethogs_unavailable' not in nethogs_raw:
        for line in nethogs_raw.split('\n'):
            if '/' in line:
                parts = line.split()
                if len(parts) >= 3:
                    try:
                        proc_name = parts[0].split('/')[-1]
                        s, r = float(parts[-2]), float(parts[-1])
                        if proc_name in process_dict:
                            process_dict[proc_name]['s'] += s
                            process_dict[proc_name]['r'] += r
                        else:
                            process_dict[proc_name] = {'s': s, 'r': r}
                    except:
                        continue
    
    app_usage = []
    sorted_apps = sorted(process_dict.items(), key=lambda x: x[1]['s'] + x[1]['r'], reverse=True)
    
    for name, flow in sorted_apps[:5]:
        if flow['s'] > 0 or flow['r'] > 0:
            app_usage.append(f"ğŸ“¦ {name.ljust(12)} | â¬†ï¸{flow['s']:.1f} â¬‡ï¸{flow['r']:.1f} KB/s")

    res = f"ğŸ“Š **æµé‡å®¡è®¡ Â· å®æ—¶ç›‘æ§**\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ³ **å®¹å™¨ç½‘ç»œ I/O (å®æ—¶)**:\n```\n"
    res += ("\n".join(dk_usage) if dk_usage else "æ— æ´»è·ƒå®¹å™¨") + "\n```\n"
    res += "ğŸ”¥ **è¿›ç¨‹å¸¦å®½å ç”¨ (TOP 5)**:\n```\n"
    res += ("\n".join(app_usage) if app_usage else "æš‚æ— æ´»è·ƒè¿›ç¨‹æµé‡") + "\n```\n"
    res += "ğŸ’¡ *å®æ—¶é‡‡æ ·ä¸­...*"
    
    kb = [
        [InlineKeyboardButton("â³ å°æ—¶è¶‹åŠ¿", callback_data="sys_traffic_h"), 
         InlineKeyboardButton("ğŸ“… 30æ—¥è´¦å•", callback_data="sys_traffic_d"), 
         InlineKeyboardButton("ğŸ³ å®æ—¶ç›‘æ§ (ç°)", callback_data="none")],
        [InlineKeyboardButton("ğŸ”„ åˆ·æ–°", callback_data="sys_traffic_r"), 
         InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="back")]
    ]
    
    return res, InlineKeyboardMarkup(kb)

def get_traffic_ranking():
    """è·å– Docker å®¹å™¨æµé‡æ’è¡Œ"""
    conf = load_config()
    
    try:
        dk_raw = subprocess.getoutput(r"docker stats --no-stream --format '{{.Name}}|{{.NetIO}}'")
        container_traffic = []
        
        for line in dk_raw.split('\n'):
            if '|' not in line:
                continue
            parts = line.split('|')
            name = parts[0]
            net_io = parts[1]
            
            try:
                io_parts = net_io.split('/')
                rx_str = io_parts[0].strip()
                tx_str = io_parts[1].strip()
                rx_gb = parse_traffic_value(rx_str)
                tx_gb = parse_traffic_value(tx_str)
                total = rx_gb + tx_gb
                container_traffic.append({
                    'name': name, 
                    'rx': rx_gb, 
                    'tx': tx_gb, 
                    'total': total
                })
            except:
                continue
        
        container_traffic.sort(key=lambda x: x['total'], reverse=True)
    except:
        container_traffic = []
    
    txt = f"ğŸ“ˆ **Docker æµé‡æ’è¡Œæ¦œ**\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    
    if container_traffic:
        txt += "ğŸ³ **å®¹å™¨æµé‡ç»Ÿè®¡** (è‡ªå¯åŠ¨ä»¥æ¥):\n"
        for idx, c in enumerate(container_traffic[:8], 1):
            bar = generate_traffic_bar(c['total'], container_traffic[0]['total'])
            txt += f"`{idx}.` {bar} `{c['name'][:15]}`\n"
            txt += f"    â†“ {c['rx']:.2f}G  â†‘ {c['tx']:.2f}G  ğŸ’° {c['total']:.2f}G\n"
    else:
        txt += "âš ï¸ æš‚æ— å®¹å™¨æµé‡æ•°æ®\n"
    
    txt += "\nğŸ’¡ **æ³¨æ„**: å®¹å™¨æµé‡ç»Ÿè®¡ä»å®¹å™¨å¯åŠ¨æ—¶å¼€å§‹è®¡ç®—"
    
    kb = [
        [InlineKeyboardButton("â³ å°æ—¶è¶‹åŠ¿", callback_data="sys_traffic_h"),
         InlineKeyboardButton("ğŸ“… 30æ—¥è´¦å•", callback_data="sys_traffic_d")],
        [InlineKeyboardButton("ğŸ”„ åˆ·æ–°", callback_data="sys_traffic_rank"),
         InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="back")]
    ]
    
    return txt, InlineKeyboardMarkup(kb)